{
  "version": 3,
  "sources": [
    "node_modules/browser-pack/_prelude.js",
    "build/serviceworker.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "'use strict';\n\nvar CACHE_NAME = 'arbiter';\n// The files we want to cache\nvar urlsToCache = ['/', './index.html', './style.css', './app.js', './polyfill.js', './babel-standalone.js', './worker.html', './serviceworker.js'];\n\n// Set the callback for the install step\nself.addEventListener('install', function (event) {\n    // console.log('installing', event)\n    // Perform install steps\n    event.waitUntil(caches.open(CACHE_NAME).then(function (cache) {\n        return(\n            // console.log(cache) ||\n            cache.addAll(urlsToCache)\n        );\n    }));\n});\n\n// Set the callback when the files get fetched\nself.addEventListener('fetch', function (event) {\n    // console.log(event.request, 'being requested')\n    event.respondWith(caches.match(event.request).then(function (response) {\n        // console.log(response)\n        // Cached files available, return those\n        if (response) {\n            return response;\n        }\n\n        // IMPORTANT: Clone the request. A request is a stream and\n        // can only be consumed once. Since we are consuming this\n        // once by cache and once by the browser for fetch, we need\n        // to clone the response\n        var fetchRequest = event.request.clone();\n\n        // Start request again since there are no files in the cache\n        return fetch(fetchRequest).then(function (response) {\n            // If response is invalid, throw error\n            if (!response || response.status !== 200 || response.type !== 'basic') {\n                return response;\n            }\n\n            // IMPORTANT: Clone the response. A response is a stream\n            // and because we want the browser to consume the response\n            // as well as the cache consuming the response, we need\n            // to clone it so we have 2 stream.\n            var responseToCache = response.clone();\n\n            // Otherwise cache the downloaded files\n            caches.open(CACHE_NAME).then(function (cache) {\n                cache.put(event.request, responseToCache);\n            });\n\n            // And return the network response\n            return response;\n        });\n    }));\n});\n\n// self.addEventListener('activate', (event) => {\n//     // console.log('activating', event)\n//     event.waitUntil(\n//         caches.keys().then((cacheNames) => {\n//             return Promise.all(\n//                 cacheNames.map((cacheName) =>\n//                     // cacheName !== CACHE_NAME &&\n//                     caches.delete(cacheName))\n//             )\n//         })\n//     )\n// })"
  ]
}